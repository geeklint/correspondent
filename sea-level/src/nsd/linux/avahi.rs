// This code was autogenerated with `dbus-codegen-rust -s -d org.freedesktop.Avahi -c nonblock -m None`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::nonblock;

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> nonblock::MethodReply<String>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopDBusIntrospectable for nonblock::Proxy<'a, C>
{
    fn introspect(&self) -> nonblock::MethodReply<String> {
        self.method_call(
            "org.freedesktop.DBus.Introspectable",
            "Introspect",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }
}

pub trait OrgFreedesktopAvahiServer {
    fn get_version_string(&self) -> nonblock::MethodReply<String>;
    fn get_apiversion(&self) -> nonblock::MethodReply<u32>;
    fn get_host_name(&self) -> nonblock::MethodReply<String>;
    fn set_host_name(&self, name: &str) -> nonblock::MethodReply<()>;
    fn get_host_name_fqdn(&self) -> nonblock::MethodReply<String>;
    fn get_domain_name(&self) -> nonblock::MethodReply<String>;
    fn is_nsssupport_available(&self) -> nonblock::MethodReply<bool>;
    fn get_state(&self) -> nonblock::MethodReply<i32>;
    fn get_local_service_cookie(&self) -> nonblock::MethodReply<u32>;
    fn get_alternative_host_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<String>;
    fn get_alternative_service_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<String>;
    fn get_network_interface_name_by_index(
        &self,
        index: i32,
    ) -> nonblock::MethodReply<String>;
    fn get_network_interface_index_by_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<i32>;
    fn resolve_host_name(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<(i32, i32, String, i32, String, u32)>;
    fn resolve_address(
        &self,
        interface: i32,
        protocol: i32,
        address: &str,
        flags: u32,
    ) -> nonblock::MethodReply<(i32, i32, i32, String, String, u32)>;
    fn resolve_service(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        type_: &str,
        domain: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<(
        i32,
        i32,
        String,
        String,
        String,
        String,
        i32,
        String,
        u16,
        Vec<Vec<u8>>,
        u32,
    )>;
    fn entry_group_new(&self) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn domain_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        domain: &str,
        btype: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn service_type_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        domain: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn service_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        type_: &str,
        domain: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn service_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        type_: &str,
        domain: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn host_name_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn address_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        address: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn record_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        clazz: u16,
        type_: u16,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>>;
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopAvahiServer for nonblock::Proxy<'a, C>
{
    fn get_version_string(&self) -> nonblock::MethodReply<String> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetVersionString",
            (),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn get_apiversion(&self) -> nonblock::MethodReply<u32> {
        self.method_call("org.freedesktop.Avahi.Server", "GetAPIVersion", ())
            .and_then(|r: (u32,)| Ok(r.0))
    }

    fn get_host_name(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.Avahi.Server", "GetHostName", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn set_host_name(&self, name: &str) -> nonblock::MethodReply<()> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "SetHostName",
            (name,),
        )
    }

    fn get_host_name_fqdn(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.Avahi.Server", "GetHostNameFqdn", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn get_domain_name(&self) -> nonblock::MethodReply<String> {
        self.method_call("org.freedesktop.Avahi.Server", "GetDomainName", ())
            .and_then(|r: (String,)| Ok(r.0))
    }

    fn is_nsssupport_available(&self) -> nonblock::MethodReply<bool> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "IsNSSSupportAvailable",
            (),
        )
        .and_then(|r: (bool,)| Ok(r.0))
    }

    fn get_state(&self) -> nonblock::MethodReply<i32> {
        self.method_call("org.freedesktop.Avahi.Server", "GetState", ())
            .and_then(|r: (i32,)| Ok(r.0))
    }

    fn get_local_service_cookie(&self) -> nonblock::MethodReply<u32> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetLocalServiceCookie",
            (),
        )
        .and_then(|r: (u32,)| Ok(r.0))
    }

    fn get_alternative_host_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<String> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetAlternativeHostName",
            (name,),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn get_alternative_service_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<String> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetAlternativeServiceName",
            (name,),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn get_network_interface_name_by_index(
        &self,
        index: i32,
    ) -> nonblock::MethodReply<String> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetNetworkInterfaceNameByIndex",
            (index,),
        )
        .and_then(|r: (String,)| Ok(r.0))
    }

    fn get_network_interface_index_by_name(
        &self,
        name: &str,
    ) -> nonblock::MethodReply<i32> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "GetNetworkInterfaceIndexByName",
            (name,),
        )
        .and_then(|r: (i32,)| Ok(r.0))
    }

    fn resolve_host_name(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<(i32, i32, String, i32, String, u32)> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ResolveHostName",
            (interface, protocol, name, aprotocol, flags),
        )
    }

    fn resolve_address(
        &self,
        interface: i32,
        protocol: i32,
        address: &str,
        flags: u32,
    ) -> nonblock::MethodReply<(i32, i32, i32, String, String, u32)> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ResolveAddress",
            (interface, protocol, address, flags),
        )
    }

    fn resolve_service(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        type_: &str,
        domain: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<(
        i32,
        i32,
        String,
        String,
        String,
        String,
        i32,
        String,
        u16,
        Vec<Vec<u8>>,
        u32,
    )> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ResolveService",
            (interface, protocol, name, type_, domain, aprotocol, flags),
        )
    }

    fn entry_group_new(&self) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.Avahi.Server", "EntryGroupNew", ())
            .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn domain_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        domain: &str,
        btype: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "DomainBrowserNew",
            (interface, protocol, domain, btype, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn service_type_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        domain: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ServiceTypeBrowserNew",
            (interface, protocol, domain, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn service_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        type_: &str,
        domain: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ServiceBrowserNew",
            (interface, protocol, type_, domain, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn service_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        type_: &str,
        domain: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "ServiceResolverNew",
            (interface, protocol, name, type_, domain, aprotocol, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn host_name_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        aprotocol: i32,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "HostNameResolverNew",
            (interface, protocol, name, aprotocol, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn address_resolver_new(
        &self,
        interface: i32,
        protocol: i32,
        address: &str,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "AddressResolverNew",
            (interface, protocol, address, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }

    fn record_browser_new(
        &self,
        interface: i32,
        protocol: i32,
        name: &str,
        clazz: u16,
        type_: u16,
        flags: u32,
    ) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call(
            "org.freedesktop.Avahi.Server",
            "RecordBrowserNew",
            (interface, protocol, name, clazz, type_, flags),
        )
        .and_then(|r: (dbus::Path<'static>,)| Ok(r.0))
    }
}

#[derive(Debug)]
pub struct OrgFreedesktopAvahiServerStateChanged {
    pub state: i32,
    pub error: String,
}

impl arg::AppendAll for OrgFreedesktopAvahiServerStateChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.state, i);
        arg::RefArg::append(&self.error, i);
    }
}

impl arg::ReadAll for OrgFreedesktopAvahiServerStateChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopAvahiServerStateChanged {
            state: i.read()?,
            error: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopAvahiServerStateChanged {
    const NAME: &'static str = "StateChanged";
    const INTERFACE: &'static str = "org.freedesktop.Avahi.Server";
}
